<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campo Eléctrico Carga Lineal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: transparent;
            font-family: 'Times New Roman', Times, serif;
        }

        canvas {
            display: block;
        }

        .label {
            position: absolute;
            color: #ffffff;
            font-size: 1.2em;
            pointer-events: none;
            text-shadow: 2px 2px 2px #000000;
            font-weight: bold;
        }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    <div id="labels"></div>
    <script>
        // --- Escena, Cámara y Renderizador ---
        const scene = new THREE.Scene();
        scene.background = null;

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(25, 20, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Transparent
        document.body.appendChild(renderer.domElement);

        // --- Controles de Órbita ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Luces ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // --- Elementos del Problema ---

        // 1. Línea Cargada Infinita (Eje Z) - BLANCA
        const lineLength = 100;
        const lineGeometry = new THREE.CylinderGeometry(0.3, 0.3, lineLength, 32);
        const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x222222 });
        const lineCharge = new THREE.Mesh(lineGeometry, lineMaterial);
        lineCharge.rotation.x = Math.PI / 2;
        scene.add(lineCharge);

        // 2. Superficie Gaussiana (Cilindro Translucido)
        const gaussRadius = 8;
        const gaussLength = 20; // L'
        const gaussGeometry = new THREE.CylinderGeometry(gaussRadius, gaussRadius, gaussLength, 32, 1, true); // Open ended? No, closed for flux? Only side contributes.
        // Step 1 math says "integral over S". Usually involves caps too but E is perpendicular to caps so 0 flux.
        // Let's make it translucent yellow/green to match standard "Gaussian" looks, or blueish?
        // User liked "white" for the bar. Let's make Gaussian surface distinct.
        const gaussMaterial = new THREE.MeshPhongMaterial({
            color: 0x44ff44, // Greenish
            opacity: 0.3,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const gaussCylinder = new THREE.Mesh(gaussGeometry, gaussMaterial);
        gaussCylinder.rotation.x = Math.PI / 2;
        scene.add(gaussCylinder);

        // Wireframe for Gaussian Cylinder to make it clearer
        const geo = new THREE.EdgesGeometry(gaussGeometry);
        const mat = new THREE.LineBasicMaterial({ color: 0x88ff88, transparent: true, opacity: 0.5 });
        const wireframe = new THREE.LineSegments(geo, mat);
        wireframe.rotation.x = Math.PI / 2;
        scene.add(wireframe);


        // 3. Ejes de Coordenadas (Pequeños, al final de la barra) - Flechas personalizadas
        const axesOrigin = new THREE.Vector3(0, 0, -48); // Near end of bar
        const axisLength = 4;
        const axisHeadLength = 1;
        const axisHeadWidth = 0.5;

        // Eje X (Rojo)
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), axesOrigin, axisLength, 0xff0000, axisHeadLength, axisHeadWidth));
        // Eje Y (Verde)
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), axesOrigin, axisLength, 0x00ff00, axisHeadLength, axisHeadWidth));
        // Eje Z (Azul)
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), axesOrigin, axisLength, 0x0000ff, axisHeadLength, axisHeadWidth));

        // --- Etiquetas HTML ---
        const labelsContainer = document.getElementById('labels');
        const labels = [
            { text: "X", pos: new THREE.Vector3(3.5, 0, -48), color: "#ff4444" },
            { text: "Y", pos: new THREE.Vector3(0, 3.5, -48), color: "#44ff44" },
            { text: "Z", pos: new THREE.Vector3(0, 0, -44.5), color: "#4444ff" },
            { text: "S (Gaussian)", pos: new THREE.Vector3(gaussRadius, gaussLength / 2, 0), color: "#88ff88" }
        ];

        // Add radius r label for Gaussian surface
        // And Length L' label

        // Arrow for r
        const rArrowDir = new THREE.Vector3(1, 0, 0);
        const rArrowOrigin = new THREE.Vector3(0, 0, 0);
        const rArrowLength = gaussRadius;
        const rArrowColor = 0x88ff88;
        const rArrow = new THREE.ArrowHelper(rArrowDir, rArrowOrigin, rArrowLength, rArrowColor, 1, 0.5);
        scene.add(rArrow);
        labels.push({ text: "r", pos: new THREE.Vector3(gaussRadius / 2, -1, 0), color: "#88ff88" });

        // Brace for L' ? Difficult in 3D. Just a label near the side?
        labels.push({ text: "L'", pos: new THREE.Vector3(0, -gaussRadius - 2, 0), color: "#88ff88" });

        // Line indicating L'? 
        // A simple line segment parallel to Z axis?
        const lpGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -gaussRadius - 1, -gaussLength / 2),
            new THREE.Vector3(0, -gaussRadius - 1, gaussLength / 2)
        ]);
        const lpLine = new THREE.Line(lpGeometry, new THREE.LineBasicMaterial({ color: 0x88ff88 }));
        scene.add(lpLine);


        labels.forEach(l => {
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = l.text;
            div.style.color = l.color;
            if (l.id) div.id = l.id;
            labelsContainer.appendChild(div);
            l.element = div;
        });

        // --- Animación ---
        function animate() {
            requestAnimationFrame(animate);

            // Proyectar etiquetas
            labels.forEach(l => {
                const vector = l.pos.clone();
                vector.project(camera);

                const xScreen = (vector.x * .5 + .5) * window.innerWidth;
                const yScreen = (-(vector.y * .5) + .5) * window.innerHeight;

                l.element.style.transform = `translate(-50%, -50%) translate(${xScreen}px, ${yScreen}px)`;

                if (Math.abs(vector.z) > 1) {
                    l.element.style.display = 'none';
                } else {
                    l.element.style.display = 'block';
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>