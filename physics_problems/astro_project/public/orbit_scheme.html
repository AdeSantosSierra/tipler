<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Esquema Órbita</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: transparent;
        }

        #viz-container {
            width: 100%;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    <div id="viz-container"></div>

    <script type="module">
        import { ThreeComponents } from './js/three-components.js';

        // --- Escena, Cámara y Renderizador ---
        const scene = new THREE.Scene();
        // Fondo transparente
        scene.background = null;

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('viz-container').appendChild(renderer.domElement);

        // --- Controles ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Luces ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- Elementos Solicitados ---

        // 1. Línea Infinita (Eje Z)
        const lineLength = 24;
        ThreeComponents.createInfiniteLine(scene, lineLength, 0.1, 0xffffff);

        // 2. Ejes Blancos Pequeños (Desplazados para no solapar con la línea)
        ThreeComponents.createSmallWhiteAxes(scene, new THREE.Vector3(-8, -5, -lineLength / 2), 4);

        // 3. Órbita Discontinua (en plano XY)
        const orbitRadius = 6;
        const orbitCurve = new THREE.EllipseCurve(
            0, 0,            // ax, aY
            orbitRadius, orbitRadius, // xRadius, yRadius
            0, 2 * Math.PI,  // aStartAngle, aEndAngle
            false,            // aClockwise
            0                 // aRotation
        );
        const points = orbitCurve.getPoints(100);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineDashedMaterial({
            color: 0xfd971f, // Monokai Orange
            dashSize: 0.5,
            gapSize: 0.3,
            scale: 1,
            opacity: 0.4, // Más atenuada
            transparent: true
        });
        const orbitLine = new THREE.Line(geometry, material);
        orbitLine.computeLineDistances(); // Importante para LineDashedMaterial
        scene.add(orbitLine);

        // 4. Partícula que orbita
        const particleGeo = new THREE.SphereGeometry(0.3, 32, 32);
        const particleMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Blanca
        const particle = new THREE.Mesh(particleGeo, particleMat);
        scene.add(particle);

        // Variables de animación
        const period = 5; // Segundos por vuelta
        const angularSpeed = (2 * Math.PI) / period;
        const clock = new THREE.Clock();

        // --- Loop de Animación ---
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const angle = angularSpeed * time;

            // Actualizar posición de la partícula (Orbita en plano XY, alrededor de Z)
            particle.position.x = orbitRadius * Math.cos(angle);
            particle.position.y = orbitRadius * Math.sin(angle);
            particle.position.z = 0;

            controls.update();
            renderer.render(scene, camera);
        }

        // Manejo de resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>