<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualización Órbita Carga Lineal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: transparent;
            font-family: 'Times New Roman', Times, serif;
        }

        canvas {
            display: block;
        }

        .label {
            position: absolute;
            color: #ffffff;
            font-size: 1.2em;
            pointer-events: none;
            text-shadow: 2px 2px 2px #000000;
            font-weight: bold;
        }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    <div id="labels"></div>
    <script type="module">
        import { ThreeComponents } from './js/three-components.js';

        // --- Escena, Cámara y Renderizador ---
        const scene = new THREE.Scene();
        scene.background = null;

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(document.getElementById('viz-container').clientWidth, 400); // Use container size
        document.getElementById('viz-container').appendChild(renderer.domElement);

        // --- Controles de Órbita ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- Luces ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // --- Elementos del Problema ---
        const lineLength = 24;
        ThreeComponents.createInfiniteLine(scene, lineLength, 0.2, 0xffffff);

        // 2. Ejes de Coordenadas (Blancos con letras)
        const axesOrigin = new THREE.Vector3(0, 0, -lineLength / 2); // Extremo
        ThreeComponents.createSmallWhiteAxes(scene, axesOrigin);

        // 3. Trayectoria de la Órbita (Círculo discontinuo)
        // Usamos BufferGeometry y LineDashedMaterial
        const orbitRadius = 10; // Moved definition here to be available for orbitPath
        const orbitCurve = new THREE.EllipseCurve(
            0, 0,            // ax, aY
            orbitRadius, orbitRadius,           // xRadius, yRadius
            0, 2 * Math.PI,  // aStartAngle, aEndAngle
            false,            // aClockwise
            0                 // aRotation
        );

        const points = orbitCurve.getPoints(100);
        // Convert 2D points to 3D (Z=0)
        const points3D = points.map(p => new THREE.Vector3(p.x, p.y, 0));
        const orbitGeo = new THREE.BufferGeometry().setFromPoints(points3D);
        const orbitMat = new THREE.LineDashedMaterial({
            color: 0xffffff,
            dashSize: 1, // Tamaño del guion
            gapSize: 1,  // Tamaño del hueco
            opacity: 0.5,
            transparent: true
        });
        const orbitPath = new THREE.Line(orbitGeo, orbitMat);
        orbitPath.computeLineDistances(); // Necesario para LineDashedMaterial
        scene.add(orbitPath);

        // 4. Partícula (Esfera Blanca Translucida)
        const particleGeometry = new THREE.SphereGeometry(0.6, 32, 32);
        const particleMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            opacity: 0.6,
            transparent: true,
            emissive: 0x444444
        });
        const particle = new THREE.Mesh(particleGeometry, particleMaterial);
        scene.add(particle);

        // Vector Unitario u_r (Flecha) -- ELIMINADO POR PETICIÓN ("No quiero vectores")

        // Radio R (Flecha elegante fija)
        // Una flecha desde el origen hasta el radio R en el eje X (fijo) o rotando?
        // "Indica de manera fija con una flecha... el radio R"
        // Si es fija, mejor que esté alineada con un eje, por ejemplo X.
        const rArrowDir = new THREE.Vector3(1, 0, 0);
        const rArrowOrigin = new THREE.Vector3(0, 0, 0);
        const rArrowLength = orbitRadius;
        const rArrowColor = 0xcccccc; // Gris claro para ser elegante
        // Usaremos ArrowHelper pero con headLength pequeño y headWidth pequeño para ser "fina"
        const rArrow = new THREE.ArrowHelper(rArrowDir, rArrowOrigin, rArrowLength, rArrowColor, 1, 0.5);
        scene.add(rArrow);

        // --- Etiquetas HTML ---
        const labelsContainer = document.getElementById('labels');
        const labels = [
            { text: "X", pos: new THREE.Vector3(3.5, 0, -lineLength / 2 + 2), color: "#ff4444" },
            { text: "Y", pos: new THREE.Vector3(0, 3.5, -lineLength / 2 + 2), color: "#44ff44" },
            { text: "Z", pos: new THREE.Vector3(0, 0, -lineLength / 2 + 5.5), color: "#4444ff" },
            { text: "R", pos: new THREE.Vector3(orbitRadius / 2, 0.5, 0), id: "r-label", color: "#ffffff" }
        ];

        labels.forEach(l => {
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = l.text;
            div.style.color = l.color;
            if (l.id) div.id = l.id;
            labelsContainer.appendChild(div);
            l.element = div;
        });

        // --- Animación ---
        let time = 0;
        const speed = 0.5;

        function animate() {
            requestAnimationFrame(animate);

            time += 0.01 * speed;

            // Posición de la partícula (Rotando)
            const x = orbitRadius * Math.cos(time);
            const y = orbitRadius * Math.sin(time);
            const z = 0;
            particle.position.set(x, y, z);

            // La flecha R es FIJA (aligned with X axis per code above) or follows particle?
            // User said "Indica de manera fija". So strict X-axis alignment is best.
            // But if particle moves and arrow is fixed, visual connection is loose.
            // However, "fija" usually means fixed in space.
            // Let's keep it fixed on X axis as implemented.

            // Proyectar etiquetas
            labels.forEach(l => {
                const vector = l.pos.clone();
                vector.project(camera);

                const xScreen = (vector.x * .5 + .5) * window.innerWidth;
                const yScreen = (-(vector.y * .5) + .5) * window.innerHeight;

                l.element.style.transform = `translate(-50%, -50%) translate(${xScreen}px, ${yScreen}px)`;

                if (Math.abs(vector.z) > 1) {
                    l.element.style.display = 'none';
                } else {
                    l.element.style.display = 'block';
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>